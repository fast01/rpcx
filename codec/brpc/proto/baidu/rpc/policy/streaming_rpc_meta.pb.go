// Code generated by protoc-gen-go. DO NOT EDIT.
// source: baidu/rpc/policy/streaming_rpc_meta.proto

package baidu_rpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/fast01/rpcx/codec/brpc/proto/baidu/rpc"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type FrameType int32

const (
	FrameType_FRAME_TYPE_UNKNOWN  FrameType = 0
	FrameType_FRAME_TYPE_RST      FrameType = 1
	FrameType_FRAME_TYPE_CLOSE    FrameType = 2
	FrameType_FRAME_TYPE_DATA     FrameType = 3
	FrameType_FRAME_TYPE_FEEDBACK FrameType = 4
)

var FrameType_name = map[int32]string{
	0: "FRAME_TYPE_UNKNOWN",
	1: "FRAME_TYPE_RST",
	2: "FRAME_TYPE_CLOSE",
	3: "FRAME_TYPE_DATA",
	4: "FRAME_TYPE_FEEDBACK",
}
var FrameType_value = map[string]int32{
	"FRAME_TYPE_UNKNOWN":  0,
	"FRAME_TYPE_RST":      1,
	"FRAME_TYPE_CLOSE":    2,
	"FRAME_TYPE_DATA":     3,
	"FRAME_TYPE_FEEDBACK": 4,
}

func (x FrameType) Enum() *FrameType {
	p := new(FrameType)
	*p = x
	return p
}
func (x FrameType) String() string {
	return proto.EnumName(FrameType_name, int32(x))
}
func (x *FrameType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FrameType_value, data, "FrameType")
	if err != nil {
		return err
	}
	*x = FrameType(value)
	return nil
}
func (FrameType) EnumDescriptor() ([]byte, []int) { return fileDescriptor6, []int{0} }

type StreamSettings struct {
	StreamId         *int64 `protobuf:"varint,1,req,name=stream_id,json=streamId" json:"stream_id,omitempty"`
	NeedFeedback     *bool  `protobuf:"varint,2,opt,name=need_feedback,json=needFeedback,def=0" json:"need_feedback,omitempty"`
	Writable         *bool  `protobuf:"varint,3,opt,name=writable,def=0" json:"writable,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *StreamSettings) Reset()                    { *m = StreamSettings{} }
func (m *StreamSettings) String() string            { return proto.CompactTextString(m) }
func (*StreamSettings) ProtoMessage()               {}
func (*StreamSettings) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0} }

const Default_StreamSettings_NeedFeedback bool = false
const Default_StreamSettings_Writable bool = false

func (m *StreamSettings) GetStreamId() int64 {
	if m != nil && m.StreamId != nil {
		return *m.StreamId
	}
	return 0
}

func (m *StreamSettings) GetNeedFeedback() bool {
	if m != nil && m.NeedFeedback != nil {
		return *m.NeedFeedback
	}
	return Default_StreamSettings_NeedFeedback
}

func (m *StreamSettings) GetWritable() bool {
	if m != nil && m.Writable != nil {
		return *m.Writable
	}
	return Default_StreamSettings_Writable
}

type StreamFrameMeta struct {
	StreamId         *int64     `protobuf:"varint,1,req,name=stream_id,json=streamId" json:"stream_id,omitempty"`
	SourceStreamId   *int64     `protobuf:"varint,2,opt,name=source_stream_id,json=sourceStreamId" json:"source_stream_id,omitempty"`
	FrameType        *FrameType `protobuf:"varint,3,opt,name=frame_type,json=frameType,enum=baidu.rpc.FrameType" json:"frame_type,omitempty"`
	HasContinuation  *bool      `protobuf:"varint,4,opt,name=has_continuation,json=hasContinuation" json:"has_continuation,omitempty"`
	Feedback         *Feedback  `protobuf:"bytes,5,opt,name=feedback" json:"feedback,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *StreamFrameMeta) Reset()                    { *m = StreamFrameMeta{} }
func (m *StreamFrameMeta) String() string            { return proto.CompactTextString(m) }
func (*StreamFrameMeta) ProtoMessage()               {}
func (*StreamFrameMeta) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{1} }

func (m *StreamFrameMeta) GetStreamId() int64 {
	if m != nil && m.StreamId != nil {
		return *m.StreamId
	}
	return 0
}

func (m *StreamFrameMeta) GetSourceStreamId() int64 {
	if m != nil && m.SourceStreamId != nil {
		return *m.SourceStreamId
	}
	return 0
}

func (m *StreamFrameMeta) GetFrameType() FrameType {
	if m != nil && m.FrameType != nil {
		return *m.FrameType
	}
	return FrameType_FRAME_TYPE_UNKNOWN
}

func (m *StreamFrameMeta) GetHasContinuation() bool {
	if m != nil && m.HasContinuation != nil {
		return *m.HasContinuation
	}
	return false
}

func (m *StreamFrameMeta) GetFeedback() *Feedback {
	if m != nil {
		return m.Feedback
	}
	return nil
}

type Feedback struct {
	ConsumedSize     *int64 `protobuf:"varint,1,opt,name=consumed_size,json=consumedSize" json:"consumed_size,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Feedback) Reset()                    { *m = Feedback{} }
func (m *Feedback) String() string            { return proto.CompactTextString(m) }
func (*Feedback) ProtoMessage()               {}
func (*Feedback) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{2} }

func (m *Feedback) GetConsumedSize() int64 {
	if m != nil && m.ConsumedSize != nil {
		return *m.ConsumedSize
	}
	return 0
}

func init() {
	proto.RegisterType((*StreamSettings)(nil), "baidu.rpc.StreamSettings")
	proto.RegisterType((*StreamFrameMeta)(nil), "baidu.rpc.StreamFrameMeta")
	proto.RegisterType((*Feedback)(nil), "baidu.rpc.Feedback")
	proto.RegisterEnum("baidu.rpc.FrameType", FrameType_name, FrameType_value)
}

func init() { proto.RegisterFile("baidu/rpc/policy/streaming_rpc_meta.proto", fileDescriptor6) }

var fileDescriptor6 = []byte{
	// 413 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x7c, 0x92, 0xc1, 0x6f, 0xda, 0x30,
	0x14, 0xc6, 0x17, 0x68, 0xa5, 0xf0, 0xd6, 0x42, 0x66, 0xd0, 0x1a, 0x6d, 0x17, 0xc6, 0x2e, 0xd0,
	0x03, 0x91, 0xba, 0xdb, 0x6e, 0x40, 0x83, 0x34, 0x75, 0xa5, 0x95, 0xc3, 0x34, 0xed, 0x64, 0x19,
	0xe7, 0xd1, 0x5a, 0x23, 0xb1, 0x15, 0x1b, 0x4d, 0x74, 0xfb, 0x87, 0xf7, 0x5f, 0x4c, 0x21, 0x4d,
	0xea, 0xd3, 0x6e, 0xd6, 0xef, 0x7d, 0x7e, 0xdf, 0x7b, 0x9f, 0x1e, 0x4c, 0x36, 0x5c, 0xa6, 0xfb,
	0xa8, 0xd0, 0x22, 0xd2, 0x6a, 0x27, 0xc5, 0x21, 0x32, 0xb6, 0x40, 0x9e, 0xc9, 0xfc, 0x81, 0x15,
	0x5a, 0xb0, 0x0c, 0x2d, 0x9f, 0xea, 0x42, 0x59, 0x45, 0x3a, 0x47, 0xe9, 0xb4, 0xd0, 0xe2, 0xdd,
	0xc5, 0xcb, 0x2f, 0xa5, 0xad, 0x54, 0xb9, 0xa9, 0x34, 0xa3, 0x3f, 0xd0, 0x4d, 0x8e, 0xff, 0x13,
	0xb4, 0x56, 0xe6, 0x0f, 0x86, 0xbc, 0x87, 0x4e, 0xd5, 0x91, 0xc9, 0x34, 0xf4, 0x86, 0xad, 0x71,
	0x9b, 0xfa, 0x15, 0xf8, 0x92, 0x92, 0x4b, 0x38, 0xcf, 0x11, 0x53, 0xb6, 0x45, 0x4c, 0x37, 0x5c,
	0xfc, 0x0c, 0x5b, 0x43, 0x6f, 0xec, 0x7f, 0x3e, 0xdd, 0xf2, 0x9d, 0x41, 0x7a, 0x56, 0xd6, 0x96,
	0xcf, 0x25, 0xf2, 0x01, 0xfc, 0x5f, 0x85, 0xb4, 0x7c, 0xb3, 0xc3, 0xb0, 0xed, 0xca, 0x1a, 0x3c,
	0xfa, 0xeb, 0x41, 0xaf, 0xb2, 0x5f, 0x16, 0x3c, 0xc3, 0x5b, 0xb4, 0xfc, 0xff, 0xfe, 0x63, 0x08,
	0x8c, 0xda, 0x17, 0x02, 0xd9, 0x8b, 0xa6, 0x1c, 0xa1, 0x4d, 0xbb, 0x15, 0x4f, 0x6a, 0xe5, 0x27,
	0x80, 0x6d, 0xd9, 0x93, 0xd9, 0x83, 0xae, 0xfc, 0xbb, 0x57, 0x83, 0x69, 0x93, 0xc8, 0xf4, 0x68,
	0xb8, 0x3e, 0x68, 0xa4, 0x9d, 0x6d, 0xfd, 0x24, 0x13, 0x08, 0x1e, 0xb9, 0x61, 0x42, 0xe5, 0x56,
	0xe6, 0x7b, 0x5e, 0x06, 0x15, 0x9e, 0x94, 0xa3, 0xd3, 0xde, 0x23, 0x37, 0x0b, 0x07, 0x93, 0x08,
	0xfc, 0x26, 0x84, 0xd3, 0xa1, 0x37, 0x7e, 0x7d, 0xd5, 0x77, 0xbb, 0x3f, 0x97, 0x68, 0x23, 0x1a,
	0x45, 0xe0, 0x37, 0xd1, 0x7c, 0x84, 0x73, 0xa1, 0x72, 0xb3, 0xcf, 0x30, 0x65, 0x46, 0x3e, 0x61,
	0xe8, 0x1d, 0x77, 0x38, 0xab, 0x61, 0x22, 0x9f, 0xf0, 0xf2, 0x37, 0x74, 0x9a, 0x21, 0xc9, 0x5b,
	0x20, 0x4b, 0x3a, 0xbb, 0x8d, 0xd9, 0xfa, 0xc7, 0x7d, 0xcc, 0xbe, 0xad, 0x6e, 0x56, 0x77, 0xdf,
	0x57, 0xc1, 0x2b, 0x42, 0xa0, 0xeb, 0x70, 0x9a, 0xac, 0x03, 0x8f, 0x0c, 0x20, 0x70, 0xd8, 0xe2,
	0xeb, 0x5d, 0x12, 0x07, 0x2d, 0xd2, 0x87, 0x9e, 0x43, 0xaf, 0x67, 0xeb, 0x59, 0xd0, 0x26, 0x17,
	0xd0, 0x77, 0xe0, 0x32, 0x8e, 0xaf, 0xe7, 0xb3, 0xc5, 0x4d, 0x70, 0x32, 0x9f, 0xc0, 0x40, 0xa8,
	0xcc, 0xd9, 0xa8, 0x3a, 0xb6, 0xf9, 0x9b, 0xa4, 0xbe, 0x36, 0xaa, 0xc5, 0x7d, 0x79, 0x42, 0xff,
	0x02, 0x00, 0x00, 0xff, 0xff, 0x21, 0x0a, 0x78, 0xf1, 0x92, 0x02, 0x00, 0x00,
}
